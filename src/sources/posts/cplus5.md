---
title: "C++ 原始指针"
date: "2024-07-27 03:57:57"
categories:
  - C_plus

---

计算机处理内存对计算机来说，内存就是一切。当你编写一个应用程序并启动它时，所有的程序都被载入到内存中，所有的指令告诉计算机在你写的代码中要做什么，所有这些都被加载到内存中。

CPU就是这样访问你的程序并开始执行它的指令的，当你创建一个变量，当你从磁盘中加载数据时所有东西都存储在内存中，如果没有内存就什么也做不了，而指针对与管理和操纵内存非常重要。



**指针是一个整数一种存储内存地址的数字**

我们显然需要一种方法来寻址所有的byte，指针就是这些地址，这是非常重要的。

因为我们在代码中的几乎所有时候都在从内存中读写。



一个指针只是一个地址，它是一个保持内存地址的整数，这就是所有，忘掉所谓的类型。

**类型与这些无关，类型只是我们为了让生活更容易而创造的某种虚构，这都不重要**

**所有类型的指针都是保持内存地址的整数**

```
#include <stdio.h>

int main()
{   
    void* prt = 0;
    printf("hello word");
    return 0;
}
```

0 实际上不是一个有效的内存地址。0是无效的这意味着这个指针是无效的。

我们不能从内存地址0中读取或写入，如果我们尝试这样做的话，我们的程序会崩溃，所以 0 意味着没有。

**类型对该内存的操作很有用，所以如果我想对它进行读写。类型可以帮助我，因为编译器会知道**

**一个整数应该是四个字节，所以我要在那么设置一个值，它会设置四个字节的内存。但最终内存是完全没有意义的。**



#### 逆向引用

指针的*运算符通常被称为 dereference 运算符，我们有变量var，指针 ptr指向 var。

```
int main()
{
    int var = 8;
    int *ptr = &var;
    *ptr = 10;
    std::cin.get();
}
```

可以打断点看一下，0a在十六进制中就是10，通过写代码的时候，逆向引用（*）一个指针。

```
\#include <iostream>

\#include <cstring>

int main()

{

  char *buffer = new char[8];

  memset(buffer, 0, 8);
  delete[] buffer; //删除
  std::cin.get();

}
```

在 C++ 中，当你使用 `new` 关键字动态分配内存时，你得到的是一个指向分配内存的指针。在你的例子中，`buffer` 是一个指向 `char` 类型的指针，它指向一个动态分配的、包含8个字符的数组。

使用 `memset` 函数可以将这块内存的全部或部分字节设置为特定的值。在你的例子中，`memset(buffer, 0, 8);` 会将 `buffer` 指向的8个字节全部设置为0。

