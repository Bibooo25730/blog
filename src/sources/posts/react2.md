---
title: "meno，callback Transition"
date: "2023-12-07 23:57:57"
categories:
  - React
---

在 React 中，“性能 Hooks” 主要指用于优化组件渲染效率的 useMemo 和 useCallback，以及与之配合的高阶组件 React.memo。

它们的核心心智模型是：通过“缓存”来避免不必要的重复计算和组件重渲染，从而提升性能。

# 🎯 核心性能 Hooks 概览

```
Hook / API	作用	简要说明
useMemo	缓存计算结果	避免在每次渲染时都进行高开销的计算。
useCallback	缓存函数引用	避免在每次渲染时都创建新的函数，常用于保证子组件 props 的稳定性。
React.memo	缓存组件渲染结果	对组件进行记忆化，避免在其 props 未变化时重新渲染（浅比较）。
```

## ⚖️ 纯 React vs. Next.js 中的关键差异

由于 useMemo 和 useCallback 是 React 的客户端 API，它们在两种环境中的核心机制完全一致。最大的差异源于 Next.js 的服务端组件。

```
特性维度	纯 React（客户端应用）	Next.js（App Router）
可用位置	可在任何组件中使用。	只能在客户端组件（使用 ‘use client’ 指令）中使用。服务端组件中不可用。
优化目标	优化客户端渲染性能，减少不必要的计算和子组件渲染。	在客户端组件中，优化目标与纯 React 一致。但更大的性能提升通常来自服务端组件的正确使用。
心智模型	“在客户端渲染树中避免浪费”。	“在客户端组件子树中避免浪费，同时优先利用服务端渲染减少客户端负载”。
滥用后果	导致代码复杂化，可能因缓存本身的开销反而降低性能。	同上，并且在服务端组件中错误地尝试使用会直接导致构建或运行时错误。
```

### 🚨 重要注意事项与最佳实践

1. 不要过早优化：优先确保功能正确和代码可读。只在性能测试（如 React DevTools Profiler）表明存在性能问题，且与这些计算或函数相关时，再使用它们。

2. 依赖项要正确：useMemo 和 useCallback 的依赖项数组必须包含回调函数内部使用的所有可变值（包括 state、props 和其他变量）。遗漏依赖项会导致使用过期的缓存值（闭包陷阱）。

3. 缓存本身有成本：记忆化需要比较依赖项和存储缓存值，并非免费的。如果计算本身很简单，或组件重渲染的开销很低，使用它们可能弊大于利。

4. useCallback 的常见误区：仅将 useCallback 用于向下传递的函数，且仅在子组件因引用变化（如被 React.memo 包裹）而进行不必要的渲染时才有意义。单纯在事件处理器上使用 useCallback 而没有被 React.memo 优化的子组件，通常不会带来性能提升。

### ⚡ Next.js 中的特殊考量与黄金法则

在 Next.js 中，关于性能有一个更高优先级的法则：尽可能将逻辑和数据获取移至服务端组件。

服务端组件本身是“免费”的：它们在服务器上渲染成静态 UI 片段，不包含状态或交互，不会增加客户端包的体积，也不会参与客户端的重渲染。这是 Next.js 带来的最根本的性能优化。

性能 Hooks 是客户端优化的工具：useMemo、useCallback、React.memo 是用来优化客户端组件渲染效率的精细工具。它们的优化层级低于服务端组件的架构优势。

正确的心智模型转变：在 Next.js 中，你应该首先问“这个组件/逻辑能否放在服务端？”，通过架构获得最大性能收益；然后，在剩余的必须交互的客户端组件中，如果确实存在性能瓶颈，再考虑使用性能 Hooks 进行微调。

### useTransition

```
用途	描述	典型场景
1. 提升交互响应（React）	在执行昂贵的、会导致UI渲染卡顿的状态更新时（如渲染大型列表），将其包裹在 startTransition 中，保持界面对其他输入（如打字、点击）的响应。	一个大型数据表格的筛选或排序操作。
2. 实现导航过渡（Next.js 专属）	在 Next.js App Router 中，结合 useRouter，在页面导航时提供 “pending” 状态，让你可以展示加载指示器，实现无缝的页面切换体验。	点击链接跳转页面时，显示一个全局加载条或骨架屏。
```

#### ⚖️ 纯 React vs. Next.js 中的关键差异

这是 最重要 的区别。useTransition 在两种环境中解决的问题 侧重点完全不同。

特性维度	纯 React（客户端应用）	Next.js（App Router）
主要目的	性能优化：防止耗时的状态更新阻塞用户交互。	用户体验优化：管理页面导航的挂起状态，实现平滑过渡。
优化对象	应用内部的、由 setState 触发的 重新渲染。	由 router.push 或 Link标签 触发的 路由切换。
心智模型	“给这个慢的更新任务一个低优先级”。	“我知道页面正在切换，让我来优雅地处理这个加载过程。”
使用频率	相对较少，仅在确有性能瓶颈的复杂交互中使用。	非常常见，是构建流畅导航体验的标准工具。

## 🚨 重要注意事项与最佳实践
```
useTransition 的作用范围：

在纯 React 中，它只影响其调用组件及其子树的渲染优先级。

在 Next.js 中导航时，isPending 会在整个应用路由切换期间保持为 true，直到新页面准备就绪。

什么可以放在 startTransition 里：

可以放：导致 React 组件重新渲染的状态更新 (setState) 或 Next.js 路由跳转 (router.push)。

不可以放：控制型的更新（如输入框的 onChange 必须即时响应的状态）、网络请求（请求本身不是状态更新，但其触发的 setState 可以包裹）。

Next.js 中的默认行为：App Router 中的 <Link> 组件内部已经自动使用了 useTransition。你通常无需手动包裹链接点击事件。手动使用 useTransition 的场景主要是在编程式导航（如 router.push）或提交表单后跳转时。

isPending 的使用：它是你向用户提供反馈的核心工具。可以用它来：

禁用提交按钮。

显示局部加载指示器。

控制全局导航栏的加载动画。
```
# 💎 总结
```
在纯 React 中，useTransition 是一个 高级性能优化工具，用于在处理计算密集型更新时保持UI的响应性。大多数应用可能用不到它。

在 Next.js 中，useTransition 的角色发生了根本转变，成为一个 核心的用户体验构建工具，专门用于管理页面导航的过渡状态，实现流畅的SPA体验。这在 Next.js 应用中非常常用。

简单来说，虽然API相同，但从纯React到Next.js，useTransition 从一个可选的性能“微调旋钮”，变成了一个构建良好导航体验的 标准配置工具。理解这种角色转变，对高效使用 Next.js 至关重要。

# useDeferredValue 
是一个用于 优化渲染性能 的 Hook，它的核心心智模型是：“延迟接收一个可能引起昂贵渲染的值，为更紧急的更新（如用户输入）让路，从而保持界面响应流畅。”

```

特性	useTransition	useDeferredValue
控制对象	控制状态更新的“动作”（函数）。你主动告诉React：“这个setState可以延后执行”。	控制状态“值”的传递。你传入一个已经变化的值，React返回一个延后的版本。
使用场景	适用于你有权控制状态更新时机的场景（例如，在事件处理函数中调用 setState）。	适用于你接收一个来自外部或上层Props的值，且无法控制其更新时机的场景。
代码位置	通常包裹触发状态更新的代码（如 setFilterValue）。	通常包裹接收到的值本身，用于延迟派生一个新值。
关系比喻	你控制水龙头的开关动作，决定水流（状态更新）何时开始。	你无法控制水源，但可以在水管上加一个缓冲水箱，让水流（值的传递）变得更平缓。
```

## 🎯 useDeferredValue 的两种核心用途

```

用途	描述	典型场景
1. 延迟派生计算	当一个值（通常来自用户输入或Props）的变化会触发下游组件昂贵的重新计算或渲染时，使用其延迟版本。	大型列表的实时搜索过滤。用户输入快速变化，但过滤和渲染列表可以稍慢。
2. 保持输入响应	确保输入框等交互控件能立即响应用户操作，而依赖于该值的复杂UI部分可以稍后更新。	一个包含复杂图表和详细面板的仪表盘，其数据依赖于一个筛选器输入。
```
### ⚖️ 纯 React vs. Next.js 中的关键差异
```

特性维度	纯 React（客户端应用）	Next.js（App Router）
可用位置	可在任何组件中使用。	只能在客户端组件（使用 ‘use client’ 指令）中使用。
优化对象	优化客户端渲染树中因Props变化导致的昂贵重渲染。	主要优化客户端组件子树内部的渲染。更大的架构优化仍优先使用服务端组件。
心智模型	“在客户端延迟处理这个会引发卡顿的值”。	“在客户端组件中，延迟处理这个会引发卡顿的值”。
```

### 🚨 重要注意事项与最佳实践
```
1. 与 useMemo 搭配使用：useDeferredValue 本身只延迟值的传递。为了阻止下游组件用延迟值进行不必要的重复计算，几乎总是需要将延迟值与 useMemo（或 useCallback）结合使用，如上例所示。

2. 它不会引起额外的网络请求：它只是推迟了React对同一个值的渲染处理，不会阻止你发起的任何异步请求（如fetch）。

3. 延迟渲染，而非延迟事件：输入框的 onChange 事件和 setFilter 会立即触发。用户输入的文字会立刻显示在输入框中。被延迟的是 deferredFilter 这个值的更新，以及因此触发的 ExpensiveList 的重新渲染。

4. 在Next.js中的定位：在Next.js应用中，最大的性能提升通常来自将数据获取和静态部分移至服务端组件。useDeferredValue 是在此基础上，对必须交互的客户端组件部分进行精细优化的工具。

## 总结 

核心：useDeferredValue 是 “以值为中心” 的延迟优化。你给它一个新值，它返回一个稍后才“追赶”上来的旧值，在这期间，React可以处理更紧急的更新。

与 useTransition 选择：

如果你在事件处理函数中并能控制状态更新（setSomething），用 useTransition。

如果你接收一个Prop或状态，并想延迟其引发的效应，用 useDeferredValue。

在Next.js中：它是一个客户端组件内的微优化工具，用于处理高频、昂贵的客户端渲染更新，是构建流畅交互体验的高级工具之一。

简单来说，useDeferredValue 让你能在快速变化的输入和慢速响应的渲染之间建立一个缓冲区，确保用户操作永远感觉迅捷。
```


